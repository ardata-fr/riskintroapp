# Helper to format a condition object
formatCondition <- function(x) {
  if (inherits(x, "condition")) {
    msg <- conditionMessage(x)
    call <- conditionCall(x)
    cl <- class(x)[1L]
    if (!is.null(call)) {
      txt <- paste0(
        cl,
        " in ",
        paste(deparse(call), collapse = "\n"),
        " :\n ",
        msg,
        "\n"
      )
    } else {
      txt <- paste0(cl, ": ", msg, "\n")
    }
    # necessary escapes for glue formatter
    gsub("\\{", "{{", txt)
  }
}


#' @importFrom cli ansi_strip
#' @importFrom rlang cnd_entrace call_name call_args_names call_args
#' @title Evaluate an expression in a safe wrapper with logging
#' @description
#' Similar to eval, but evaluation occurs inside a try and withCallingHandlers wrapper.
#' It captures and logs conditions (errors, warnings, messages).
#'
#' @inheritParams base::eval
#' @param warningHandler Extra handler for warnings
#'
#' @return The result of the expression or a try-error object.
#' @noRd
safe_eval <- function(
    expr,
    envir = parent.frame(),
    enclos = if (is.list(envir) || is.pairlist(envir)) {
      parent.frame()
    } else {
      baseenv()
    },
    warningHandler = NULL
) {
  # record user's call
  userCall <- sys.call(0)
  # eval inside try with handlers to catch and log conditions
  try({
    withCallingHandlers(
      eval(expr, envir = envir, enclos = enclos),
      condition = function(cnd) {
        # add trace
        cnd <- cnd_entrace(cnd)
        if (!is.null(cnd$trace)) {
          # If the condition occurred at the top level of the expression,
          # its call will be "withCallingHandlers..." and that's not informative at all.
          # Below we compare the parent of the condition call with the user's call.
          # If they are the same, we use the user's call in condition formatting.
          callCnt <- length(cnd$trace$parents)
          parent <- cnd$trace$parents[[callCnt]]
          lastCall <- cnd$trace$calls[[parent]]
          if (
            !is.null(lastCall) &&
            identical(call_name(userCall), call_name(lastCall)) &&
            identical(call_args_names(userCall), call_args_names(lastCall)) &&
            identical(call_args(userCall), call_args(lastCall))
          ) {
            cnd$call <- userCall
          }
        }
        # format and log
        msg <- formatCondition(cnd)
        if (inherits(cnd, "error")) {
          stop(cli::ansi_strip(msg))
        } else if (inherits(cnd, "warning")) {
          if (is.function(warningHandler)) {
            warningHandler(cnd)
          }
        } else if (inherits(cnd, "message")) {
          if (is.function(warningHandler)) {
            warningHandler(cnd)
          }
        }
      }
    )
  })
}

#' @title Extract the Message from a Try-Error or Error Object
#' @description
#' Retrieves the error message from a \code{try-error} or an error object. If the error originates
#' from \pkg{rlang}, the CLI formatting is disabled before extracting the message.
#' @param x A \code{try-error} or an error object (e.g., an object of class \code{"error"} or \code{"rlang_error"}).
#' @details
#' This function handles various types of error objects, including those generated by \code{\link[base]{try}}
#' or \pkg{rlang}. If the input is a \code{try-error}, the underlying error condition is extracted
#' from the \code{"condition"} attribute. For \code{rlang} errors, CLI formatting is turned off
#' to ensure the message is returned as plain text.
#'
#' The function uses \code{\link[base]{conditionMessage}} to extract the error message once the
#' object is properly handled.
#' @return
#' A character string containing the error message.
#' @examples
#' # Example with a try-error
#' err <- try(stop("This is an error"), silent = TRUE)
#' get_error_message(err)  # Returns "This is an error"
#'
#' # Example with an error object
#' tryCatch(
#'   stop("Another error"),
#'   error = function(e) {
#'     print(get_error_message(e))  # Returns "Another error"
#'   }
#' )
#'
#' # Example with an rlang error
#' tryCatch(
#'   rlang::abort("This is an rlang error"),
#'   error = function(e) {
#'     print(get_error_message(e))  # Returns "Another error"
#'   }
#' )
#' @noRd
#' @importFrom stringr str_squish str_trim str_extract str_locate fixed
#' str_sub
get_error_message <- function(x) {
  if (inherits(x, "try-error")) {
    x <- attr(x, "condition")
  }

  if (inherits(x, "rlang_error")) {
    x$use_cli_format <- FALSE
  }
  str <- conditionMessage(x)
  if (grepl("error_call = current_env()) :", str, fixed = TRUE)) {
    last_details_loc <- str_locate(
      string = str,
      pattern = fixed("error_call = current_env()) :")
    )
    last_details_loc <- as.vector(last_details_loc)
    last_details <- str_sub(str, start = last_details_loc[2] + 1)
    last_details <- str_squish(last_details)
    str <- str_trim(last_details)
  }

  gsub("simpleError\\: ", "", str)
}


#' Strip ANSI Escape Codes from a String
#'
#' Removes ANSI escape codes from a character vector, which are commonly used for terminal text formatting (e.g., colors, bold).
#'
#' @param x A character vector potentially containing ANSI escape codes.
#'
#' @details
#' This function uses \code{\link[cli]{ansi_strip}} to clean a character vector by removing any embedded ANSI escape sequences.
#' These sequences are often used for styling terminal outputs but can interfere with text processing or rendering in contexts where plain text is expected.
#'
#' @return
#' A character vector with all ANSI escape codes removed.
#'
#' @examples
#' # Example with ANSI-styled text
#' styled_text <- "\033[31mThis is red text\033[0m"
#' as_ansi_striped(styled_text)  # Returns "This is red text"
#'
#' # Example with plain text (no effect)
#' plain_text <- "This is plain text"
#' as_ansi_striped(plain_text)  # Returns "This is plain text"
#' @importFrom cli ansi_strip
#' @noRd
as_ansi_striped <- function(x) {
  ansi_strip(x)
}

#' @title Checks if an Object is an Error
#' @description
#' Determines whether an object is an error, specifically if it inherits from
#' the classes `error` or `try-error`.
#' @param x The object to test. Can be of any type.
#' @details
#' This function checks if the input object `x` belongs to one of the following
#' classes:
#'
#' - `error`: Typically associated with error objects generated within R.
#' - `try-error`: Produced by the [try()] function when an error occurs.
#'
#' It is useful for programmatically identifying error objects and handling
#' them in a controlled way, particularly in workflows where errors might
#' arise and need to be processed or logged.
#' @return
#' A logical value: `TRUE` if `x` is an error object; otherwise, `FALSE`.
#' @examples
#' # Example with an error object
#' err <- try(stop("This is an error"), silent = TRUE)
#' is_error(err)
#'
#' # Example with a non-error object
#' is_error(42)
#' @noRd
#' @importFrom rlang inherits_any
is_error <- function(x) {
  inherits_any(x, c("error", "try-error"))
}


#' @title Generate an Operation Status Object
#' @description
#' This function creates a status object for an operation, allowing the specification
#' of error, warning, and informational messages. It also ensures that curly
#' braces `{` and `}` in messages are properly escaped.
#' @param status A character string specifying the status of the node. Must be one of
#'   `"success"`, `"error"`, `"warning"`, or `"none"`.
#' @param error_chr Optional character string containing an error message.
#'   Curly braces `{}` are escaped to `{{` and `}}`.
#' @param warning_chr Optional character string containing a warning message.
#'   Curly braces `{}` are escaped to `{{` and `}}`.
#' @param info_chr Optional character string containing an informational message.
#' @return A named list with the following elements:
#' - `error_chr`: (Character or NULL) Processed error message.
#' - `warning_chr`: (Character or NULL) Processed warning message.
#' - `info_chr`: (Character or NULL) Informational message.
#' - `status`: (Character) The validated status.
#' @examples
#' operation_status("success")
#' operation_status("error", error_chr = "An error occurred.")
#' operation_status("warning", warning_chr = "Check your input.")
#' @noRd
operation_status <- function(
    status,
    error_chr = NULL,
    warning_chr = NULL,
    info_chr = NULL
) {
  x <- list(
    error_chr = error_chr,
    warning_chr = warning_chr,
    info_chr = info_chr
  )
  if (!is.null(x$error_chr)) {
    x$error_chr <- gsub("\\{", "{{", x$error_chr)
    x$error_chr <- gsub("\\}", "}}", x$error_chr)
  }
  if (!is.null(x$warning_chr)) {
    x$warning_chr <- gsub("\\{", "{{", x$warning_chr)
    x$warning_chr <- gsub("\\}", "}}", x$warning_chr)
  }
  if (status %in% c("success", "error", "warning", "none")) {
    x$status <- status
  } else {
    stop("invalid status value: ", status)
  }
  x
}


#' @title Quote and Collapse Values into a Single String
#' @description
#' Formats a vector of values by surrounding each element with a specified quote character and
#' concatenating them with a separator. The last element is joined with a different separator
#' (e.g., "and") for better readability.
#' @param value A character vector containing the values to format.
#' @param quote_char A character string used to surround each value. Defaults to \code{"`"}.
#' @details
#' This function is useful for creating readable lists of quoted values, such as column names or
#' descriptive strings. The function uses \code{\link[glue]{glue_collapse}} to concatenate the values,
#' with the option to specify a different separator for the last element.
#' @return
#' A single character string with all values quoted and concatenated.
#' @examples
#' # Basic usage
#' quote_and_collapse(c("name", "age", "gender"))
#' # Returns "`name`, `age` and `gender`"
#'
#' # Custom quote character
#' quote_and_collapse(c("A", "B", "C"), quote_char = "'")
#' # Returns "'A', 'B' and 'C'"
#' @noRd
#' @importFrom glue glue_collapse
quote_and_collapse <- function(value, quote_char = "`") {
  paste0(
    quote_char,
    glue_collapse(
      x = value,
      sep = paste0(quote_char, ", ", quote_char),
      last = paste0(quote_char, " and ", quote_char)
    ),
    quote_char
  )
}

